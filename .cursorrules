# Cursor IDE Rules for Telegram Automation System
# These rules help AI assistants and Cursor IDE understand the project better

## Project Context
This is a Telegram Automation System built with Python 3.11+ using Clean Architecture principles.

## Architecture Overview
- **Language**: Python 3.11+
- **Pattern**: Clean Architecture with layered approach
- **Database**: MongoDB with Motor (async)
- **Telegram**: Pyrogram (MTProto) + python-telegram-bot
- **Structure**: src/core, src/models, src/services, src/telegram

## Code Style Guidelines

### Python Standards
- Follow PEP 8 for code style
- Use type hints for all function parameters and returns
- Use absolute imports with 'src.' prefix
- Maximum line length: 100 characters
- Use 4 spaces for indentation

### Architecture Rules
- **Dependency Direction**: Dependencies point inward (core <- models <- services <- telegram)
- **Layer Separation**: No direct imports between non-adjacent layers
- **Interface Pattern**: Use abstract base classes for external interfaces
- **Service Pattern**: Business logic only in services layer

### Import Organization
```python
# Standard library imports
import asyncio
from pathlib import Path

# Third-party imports
from pydantic import BaseModel
from loguru import logger

# Local imports
from src.core.config import settings
from src.models.message import Message
from src.services.message_service import MessageService
```

## File Organization

### Core Layer (`src/core/`)
- `config.py`: Configuration management with Pydantic
- `database.py`: MongoDB connection and base operations
- No business logic - only infrastructure concerns

### Models Layer (`src/models/`)
- Domain entities with Pydantic models
- UUID-based identifiers (no MongoDB ObjectIds)
- Pure data structures with validation
- No external dependencies except Pydantic

### Services Layer (`src/services/`)
- Business logic and use cases
- Repository pattern for data access
- Error handling and validation
- Async/await pattern for all operations

### Telegram Layer (`src/telegram/`)
- Bot handlers and userbot integration
- Interface adapters for external APIs
- No business logic - only interface concerns

## Common Patterns

### Error Handling
```python
from loguru import logger

try:
    result = await service.operation()
    logger.info(f"Operation successful: {result}")
except SpecificError as e:
    logger.error(f"Specific error occurred: {e}")
    # Handle gracefully
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    raise
```

### Service Pattern
```python
from abc import ABC, abstractmethod
from typing import List, Optional
from src.models.entity import Entity

class EntityService:
    def __init__(self):
        self.repository = EntityRepository()
    
    async def create(self, data: dict) -> Entity:
        entity = Entity(**data)
        return await self.repository.save(entity)
    
    async def get_all_active(self) -> List[Entity]:
        return await self.repository.find({"is_active": True})
```

### Database Operations
```python
from motor.motor_asyncio import AsyncIOMotorCollection
from src.core.database import Database

class EntityRepository:
    def __init__(self):
        self.db = Database()
        self.collection: AsyncIOMotorCollection = None
    
    async def _get_collection(self):
        if not self.collection:
            self.collection = self.db.get_collection("entities")
        return self.collection
```

## Documentation Rules

### When to Document
- Public APIs and interfaces
- Complex business logic
- Architecture decisions (ADRs)
- Setup and configuration

### When NOT to Document
- Implementation details
- Temporary fixes
- Code that is self-explanatory
- Every function (use clear naming instead)

### Docstring Format
```python
async def complex_operation(param1: str, param2: int) -> Optional[dict]:
    """
    Performs complex operation with specific business rules.
    
    Args:
        param1: Description of what this parameter does
        param2: Description of what this parameter does
    
    Returns:
        Optional dict with operation results, None if operation failed
        
    Raises:
        SpecificError: When specific condition occurs
    """
```

## Testing Guidelines

### Health Check Usage
- Always run `python scripts/health_check.py` before commits
- Must pass 5/5 checks for successful validation
- Checks dependencies, imports, file structure, and configuration

### Manual Testing
- Use `scripts/setup.py` for test environment
- Test with actual Telegram credentials when possible
- Monitor logs at `logs/app.log` for issues

## Security Considerations

### Credentials
- Never hardcode API keys or tokens
- Use environment variables via `.env` file
- Don't log sensitive information
- Use dedicated Telegram account for testing

### Input Validation
- Validate all user inputs in services layer
- Use Pydantic models for data validation
- Sanitize data before database operations

## Performance Guidelines

### Database Operations
- Use proper indexes for queries
- Batch operations when possible
- Use UUID strings instead of ObjectIds for JSON serialization

### Telegram Operations
- Implement proper rate limiting
- Handle slowmode and flood limits gracefully
- Use connection pooling for high volume

## AI Assistant Guidelines

When helping with this project:
1. Follow the clean architecture principles
2. Suggest proper layer placement for new code
3. Recommend creating ADRs for architectural decisions
4. Always consider the health check requirements
5. Suggest running health check after significant changes
6. Reference existing patterns in the codebase
7. Consider security implications of suggestions
8. Recommend proper error handling and logging

## Common Mistakes to Avoid

1. **Cross-layer dependencies**: Don't import services in models
2. **Direct database access**: Use repository pattern in services
3. **Business logic in handlers**: Keep it in services layer
4. **Hardcoded values**: Use configuration or constants
5. **Synchronous operations**: Use async/await for I/O operations
6. **Ignoring type hints**: Always provide type annotations
7. **Missing error handling**: Always handle expected exceptions

## File Templates

### New Service Template
```python
from typing import List, Optional
from loguru import logger
from src.models.entity import Entity
from src.core.database import Database

class EntityService:
    def __init__(self):
        self.db = Database()
    
    async def create(self, **kwargs) -> Entity:
        # Implementation
        pass
    
    async def get_by_id(self, entity_id: str) -> Optional[Entity]:
        # Implementation  
        pass
```

### New Model Template
```python
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field
import uuid

class Entity(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    is_active: bool = True
    
    class Config:
        validate_assignment = True
```